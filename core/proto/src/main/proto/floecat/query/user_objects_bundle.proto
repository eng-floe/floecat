// Copyright 2026 Yellowbrick Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

/**
 * User objects bundle API.
 *
 * Streams catalog metadata for user objects so planners can see each resolved input
 * as soon as it exists.
 *
 * The protocol is:
 *   - a single header chunk
 *   - zero-or-more RelationResolutions chunks
 *   - a single end summary chunk
 */
package ai.floedb.floecat.query;

import "floecat/common/common.proto";
import "floecat/query/engine_specific.proto";
import "floecat/query/sql_objects.proto";
import "floecat/query/system_objects_registry.proto";

option java_multiple_files = true;
option java_package = "ai.floedb.floecat.query.rpc";
option java_outer_classname = "UserObjectsProto";

/**
 * Service that resolves planner inputs and streams user object metadata.
 */
service UserObjectsService {
  /**
   * GetUserObjects resolves each requested logical reference and streams results.
   */
  rpc GetUserObjects(GetUserObjectsRequest) returns (stream UserObjectsBundleChunk);
}

/**
 * One logical reference from the planner (for example "a" in `SELECT ... FROM a`).
 *
 * The planner expands the search_path and sends ordered candidates to try.
 *
 * Example: candidates=[public1.a, pg.a]
 */
message TableReferenceCandidate {
  /** Ordered candidate inputs the planner is willing to accept for this logical reference. */
  repeated ai.floedb.floecat.common.QueryInput candidates = 1;

  /** Optional projected column list used to avoid re-requesting already-present columns. */
  repeated string initial_columns = 2;

  /** When true, the planner wants all columns regardless of `initial_columns`. */
  bool wants_all_columns = 3;
}

/**
 * Request to resolve user objects referenced by a planner.
 */
message GetUserObjectsRequest {
  /** Query ID obtained from BeginQuery. */
  string query_id = 1;

  /** Planner references expressed as ordered candidates; responses include `input_index`. */
  repeated TableReferenceCandidate tables = 2;
}

/**
 * One streamed chunk of the user objects bundle.
 */
message UserObjectsBundleChunk {
  /** Query context identifier for correlation. */
  string query_id = 1;

  /** Monotonic sequence number within the stream. */
  uint64 seq = 2;

  /**
   * Chunk payload.
   *
   * The stream starts with a `header`, continues with zero-or-more `resolutions`,
   * and ends with an `end` summary.
   */
  oneof payload {
    /** Stream header (sent once at the start). */
    UserObjectsBundleHeader header = 10;

    /** Resolution results (may contain multiple items for efficiency). */
    RelationResolutions resolutions = 20;

    /** End-of-stream summary (sent once at the end). */
    UserObjectsBundleEnd end = 90;
  }
}

/**
 * Stream header for a user objects bundle.
 */
message UserObjectsBundleHeader {
  /** Optional warnings computed before streaming begins. */
  repeated ResolutionWarning warnings = 1;
}

/**
 * End-of-stream summary for a user objects bundle.
 */
message UserObjectsBundleEnd {
  /** Number of input references the server attempted to resolve (typically request.tables count). */
  uint32 resolution_count = 1;

  /** Number of inputs that resolved to an actual relation. */
  uint32 found_count = 2;

  /** Number of inputs that could not be resolved. */
  uint32 not_found_count = 3;
}

/**
 * Non-fatal warning emitted during resolution.
 */
message ResolutionWarning {
  /** Machine-readable warning identifier. */
  string code = 1;

  /** Human-friendly warning message. */
  string message = 2;
}

/**
 * Resolution outcome for a single planner input.
 */
enum ResolutionStatus {
  /** Resolution status is not specified. */
  RESOLUTION_STATUS_UNSPECIFIED = 0;

  /** The input resolved successfully to a relation. */
  RESOLUTION_STATUS_FOUND = 1;

  /** The input did not resolve to any relation. */
  RESOLUTION_STATUS_NOT_FOUND = 2;

  /** Resolution failed with an error but the stream continues. */
  RESOLUTION_STATUS_ERROR = 3;
}

/**
 * Result for one input entry from `request.tables[]`.
 *
 * `input_index` ties the response back to the plannerâ€™s reference list.
 */
message RelationResolution {
  /** Index into `request.tables[]` so the planner can correlate responses. */
  uint32 input_index = 1;

  /** Resolution outcome for this input. */
  ResolutionStatus status = 2;

  /** Populated when `status` is FOUND. */
  RelationInfo relation = 10;

  /** Populated for NOT_FOUND/ERROR outcomes with diagnostics. */
  ResolutionFailure failure = 11;
}

/**
 * Batch of resolution results carried by a single streamed chunk.
 */
message RelationResolutions {
  /** Resolution results contained in a single chunk. */
  repeated RelationResolution items = 1;
}

/**
 * Resolution failure diagnostic.
 */
message ResolutionFailure {
  /** Machine-readable failure code (for example: "catalog_bundle.relation_not_found"). */
  string code = 1;

  /** Human-readable summary of the failure. */
  string message = 2;

  /** Attempted inputs that the server tried for this logical reference. */
  repeated ai.floedb.floecat.common.QueryInput attempted = 3;

  /** Optional structured metadata to help debugging. */
  map<string, string> details = 10;
}

/**
 * Kind of relation resolved by the catalog.
 */
enum RelationKind {
  /** Relation kind is not specified. */
  RELATION_KIND_UNSPECIFIED = 0;

  /** Regular table. */
  RELATION_KIND_TABLE = 1;

  /** View defined by SQL. */
  RELATION_KIND_VIEW = 2;

  /** System view (for example in information_schema). */
  RELATION_KIND_SYSTEM_VIEW = 3;

  /** Temporary relation scoped to the current session/query. */
  RELATION_KIND_TEMP = 4;
}

/**
 * Resolved relation metadata returned to the planner.
 */
message RelationInfo {
  /** Unique resource identity of the relation (table/view). */
  ai.floedb.floecat.common.ResourceId relation_id = 1;

  /** Canonical name of the relation for humans. */
  ai.floedb.floecat.common.NameRef name = 2;

  /** Relation kind (table, view, etc.) to help the planner decide how to bind. */
  RelationKind kind = 3;
  
  /** Column results describing usable columns and per-column failures. */
  repeated ColumnResult columns = 4;
  
  /** Optional view definition for relations of kind VIEW. */
  ViewDefinition view_definition = 5;
  
  /** Optional table-level statistics from a cached catalog snapshot. */
  RelationStats stats = 6;
  
  /** Origin indicates whether the relation is user-defined or system. */
  ai.floedb.floecat.query.Origin origin = 7;

  /** 
   * Execution backend storage kind.
   * Only set for system tables
   */
  optional TableBackendKind backend_kind = 8;
  
  /**
   * Execution endpoint metadata for builtin tables. FLOECAT tables always present a Flight
   * endpoint, while STORAGE tables either expose their own Flight endpoint or surface a
   * storage path (but never both). Workers use whichever field is set to reach the backend.
   */
  oneof endpoint {
    FlightEndpointRef flight_endpoint = 9;
    string storage_path = 10;
  }

  /** Optional engine-specific metadata extensions. */
  repeated ai.floedb.floecat.query.EngineSpecific engine_specific = 99;
}

/** Status of a resolved relation column. */
enum ColumnStatus {
  COLUMN_STATUS_UNSPECIFIED = 0;
  COLUMN_STATUS_OK = 1;
  COLUMN_STATUS_FAILED = 2;
}

/** Machine-readable reason why the RPC could not return complete / correct column results. */
enum ColumnFailureCode {
  /** Unspecified or unknown failure. */
  COLUMN_FAILURE_CODE_UNSPECIFIED = 0;

  /**
   * The request inputs and the resolved relation/schema are structurally inconsistent.
   *
   * Use when the RPC cannot reliably align requested columns with the resolved schema.
   *
   * Examples:
   * - The resolved/pruned schema is missing or has a different column count than requested
   * - The schema/columns alignment is lost (projection/order drift) such that per-column
   *   results cannot be constructed deterministically
   *
   * Typically indicates planner/schema propagation drift or an internal mismatch between
   * request shape and resolved relation schema.
   */
  COLUMN_FAILURE_CODE_SCHEMA_MISMATCH = 1;

  /**
   * A required subsystem needed to fulfill the RPC is unavailable.
   *
   * Examples:
   * - Engine metadata provider/decorator is not registered or disabled
   * - Required engine module/plugin not loaded
   * - Feature not available for the target engine or relation type
   */
  COLUMN_FAILURE_CODE_DECORATOR_UNAVAILABLE = 2;

  /**
   * A required request field or resolved input payload is missing.
   *
   * Use when the RPC requires specific metadata/annotations to proceed and they are absent.
   *
   * Examples:
   * - Missing column logical type string/annotation when the RPC requires it
   * - Missing engine-specific identifiers or metadata required to fetch/compute results
   * - Missing relation identifier / context required for the operation
   */
  COLUMN_FAILURE_CODE_ENGINE_PAYLOAD_REQUIRED_MISSING = 3;

  /**
   * The caller is not authorized to perform this operation or access required metadata.
   *
   * Examples:
   * - Insufficient privileges to read relation/column metadata
   * - Engine denies access to required metadata for the caller
   */
  COLUMN_FAILURE_CODE_PERMISSION_DENIED = 4;

  /**
   * The RPC cannot handle the column's physical type for the requested operation.
   *
   * Examples:
   * - A column type is outside the supported set for this RPC
   * - The engine/provider cannot represent or process the type
   */
  COLUMN_FAILURE_CODE_TYPE_NOT_SUPPORTED = 5;

  /**
   * The column logical type information is invalid, malformed, or semantically inconsistent.
   *
   * Use when logical type metadata exists but cannot be parsed or does not make sense.
   * This is distinct from SCHEMA_MISMATCH: the schema may be aligned, but the logical typing
   * metadata is not usable.
   *
   * Examples:
   * - Logical type string fails to parse (invalid syntax/format)
   * - Invalid logical parameters (e.g., DECIMAL scale > precision)
   * - Logical type incompatible with the physical type
   */
  COLUMN_FAILURE_CODE_LOGICAL_TYPE_INVALID = 6;

  /**
   * The requested column or its required metadata could not be found.
   *
   * Examples:
   * - Column name/identifier does not exist in the resolved relation
   * - Column was dropped/renamed and cannot be resolved
   * - Required per-column metadata lookup returns no entry
   */
  COLUMN_FAILURE_CODE_NOT_FOUND = 7;

  /**
   * A generic internal error occurred while processing the RPC.
   *
   * Use when the failure does not fit a more specific code above.
   */
  COLUMN_FAILURE_CODE_INTERNAL_ERROR = 8;

  /**
   * An engine/plugin boundary returned an error while fulfilling the RPC.
   *
   * Use for failures originating inside engine extensions/plugins/providers after they
   * were invoked (e.g., engine internal error, extension exception).
   */
  COLUMN_FAILURE_CODE_ENGINE_EXTENSION = 9;
}

/** Failure diagnostic for a single column. */
message ColumnFailure {
  /** Machine-readable column failure code enum. */
  ColumnFailureCode code = 1;

  /** Human-readable summary of the column failure. */
  string message = 2;

  /** Optional structured metadata to help debugging. */
  map<string, string> details = 10;

  /**
   * Optional engine-specific numeric failure code.
   * Engine kind/version already identify the extension domain.
   * When set, `code` should be `COLUMN_FAILURE_CODE_ENGINE_EXTENSION`.
   */
  optional int32 extension_code_value = 11;
}

/** Outcome for a single relation column. */
message ColumnResult {
  /** Stable column identifier. */
  int64 column_id = 1;

  /** Column display name. */
  string column_name = 2;

  /** Column ordinal (1-based). */
  int32 ordinal = 3;

  /** Per-column readiness status. */
  ColumnStatus status = 4;

  oneof outcome {
    /** Present when status == READY. */
    ColumnInfo column = 10;

    /** Present when status == FAILED. */
    ColumnFailure failure = 11;
  }
}

/**
 * Optional relation statistics returned from a cached snapshot.
 */
message RelationStats {
  /** Estimated row count for the relation. */
  int64 row_count = 1;

  /** Estimated total size in bytes for the relation. */
  int64 total_size_bytes = 2;
}

/**
 * Column metadata for a resolved relation.
 */
message ColumnInfo {
  // Unique column ID within the relation used in Floecat.
  int64 id = 1;
  
  // Column name.
  string name = 2;

  /** Logical type identifier for the column. */
  ai.floedb.floecat.common.NameRef type = 3;

  /** Whether NULL is allowed. */
  bool nullable = 4;
  
  // Ordinal position within the table schema : 1-based within the parent struct.
  int32 ordinal = 5;

  /** Origin marks builtin vs user columns (propagated from relation origin). */
  ai.floedb.floecat.query.Origin origin = 6;

  /** Engine-specific metadata extensions (optional). */
  repeated ai.floedb.floecat.query.EngineSpecific engine_specific = 99;
}

/**
 * Optional view definition for resolved relations of kind VIEW.
 */
message ViewDefinition {
  /** Canonical SQL definition of the view. */
  string canonical_sql = 1;

  /** Dialect used to produce the canonical SQL. */
  string dialect = 2;

  /** Base relations that the view depends on. */
  repeated ai.floedb.floecat.common.ResourceId base_relations = 3;

  /** Search path as captured when the view was created. */
  repeated string creation_search_path = 4;

  /** Engine-specific metadata extensions (collations, hints, etc.). */
  repeated ai.floedb.floecat.query.EngineSpecific engine_specific = 99;
}
