// Copyright 2026 Yellowbrick Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";
package ai.floedb.floecat.extensions.floedb.proto;

option java_multiple_files = true;
option java_package = "ai.floedb.floecat.extensions.floedb.proto";

/**
 * FloeDB engine-specific metadata.
 *
 * This proto captures FloeDB/PG-catalog-derived attributes that are not portable
 * across engines.
 *
 * These messages are attached through the generic `EngineSpecific` extension
 * mechanism to enrich the unified SQL object model.
 */

/**
 * Engine-specific namespace attributes (pg_namespace).
 */
message FloeNamespaceSpecific {
  /** Namespace OID (primary identity). */
  optional uint32 oid = 1;

  /** Namespace name (nspname). */
  optional string nspname = 2;
}

/**
 * Engine-specific relation attributes (pg_class).
 */
message FloeRelationSpecific {
  /** Relation OID (pg_class.oid). */
  optional uint32 oid = 1;

  /** Relation name (relname). */
  optional string relname = 2;

  /** Namespace OID (relnamespace). */
  optional uint32 relnamespace = 3;

  /** Relation kind (relkind: r, v, m, i, S, c, f, p). */
  optional string relkind = 4;

  /** Estimated number of rows in the relation (reltuples). */
  optional float reltuples = 5;
}

/**
 * Engine-specific column attributes (pg_attribute).
 */
message FloeColumnSpecific {
  /** Column name (attname). */
  optional string attname = 1;

  /** Column type OID (atttypid). */
  optional uint32 atttypid = 2;

  /** Type modifier (atttypmod). */
  optional int32 atttypmod = 3;

  /** Attribute number (attnum). */
  optional int32 attnum = 4;

  /** True if column is NOT NULL (attnotnull). */
  optional bool attnotnull = 5;

  /** Collation OID (attcollation). */
  optional uint32 attcollation = 6;

  /** True if column has a default value (atthasdef). */
  optional bool atthasdef = 7;
  
  /** True if column is dropped (attisdropped). */
  optional bool attisdropped = 8;
}

/**
 * Engine-specific function attributes (pg_proc).
 */
message FloeFunctionSpecific {
  /** Function OID (pg_proc.oid). */
  optional uint32 oid = 1;

  /** Function name (proname). */
  optional string proname = 2;

  /** Function namespace OID (pronamespace). */
  optional uint32 pronamespace = 3;

  /** Owner role OID (proowner). */
  optional uint32 proowner = 4;

  /** Language OID (prolang). */
  optional uint32 prolang = 5;

  /** Planner cost estimate (procost). */
  optional float procost = 6;

  /** Estimated rows returned (prorows). */
  optional float prorows = 7;

  /** Variadic element type OID, if variadic (provariadic). */
  optional uint32 provariadic = 8;

  /** Transform OID (protransform). */
  optional uint32 protransform = 9;

  /** True if this function is an aggregate (proisagg). */
  optional bool proisagg = 10;

  /** True if this function is a window function (proiswindow). */
  optional bool proiswindow = 11;

  /** True if this function is SECURITY DEFINER (prosecdef). */
  optional bool prosecdef = 12;

  /** True if function is leakproof (proleakproof). */
  optional bool proleakproof = 13;

  /** True if NULL inputs imply NULL result (proisstrict). */
  optional bool proisstrict = 14;

  /** True if function returns a set (proretset). */
  optional bool proretset = 15;

  /** Volatility category (provolatile). One-character PG code stored as a string. */
  optional string provolatile = 16;

  /** Number of input arguments (pronargs). */
  optional int32 pronargs = 17;

  /** Number of default arguments (pronargdefaults). */
  optional int32 pronargdefaults = 18;

  /** Return type OID (prorettype). */
  optional uint32 prorettype = 19;

  /** Yellowbrick-specific cost estimate (proybcost). */
  optional int32 proybcost = 20;

  /** Input argument type OIDs (proargtypes). */
  repeated uint32 proargtypes = 21;

  /** Length of the proargtypes array (planner-facing convenience). */
  optional int32 proargtypelen = 22;
}

/**
 * Engine-specific cast attributes (pg_cast).
 */
message FloeCastSpecific {
  /** Source type OID (castsource). */
  optional uint32 castsource = 1;

  /** Target type OID (casttarget). */
  optional uint32 casttarget = 2;

  /** Function OID implementing the cast (castfunc). */
  optional uint32 castfunc = 3;

  /** Cast context (castcontext). */
  optional string castcontext = 4;

  /** Cast method (castmethod). */
  optional string castmethod = 5;
}

/**
 * Engine-specific type attributes (pg_type).
 */
message FloeTypeSpecific {
  /** Type OID (pg_type.oid). */
  optional uint32 oid = 1;

  /** Type name (typname). */
  optional string typname = 2;
  
  /** Type namespace OID (typnamespace). */
  optional uint32 typnamespace = 3;

  /** Type length (typlen). Signed to allow negative varlena codes. */
  optional int32 typlen = 4;

  /** True if passed by value (typbyval). */
  optional bool typbyval = 5;

  /** Type delimiter for array formatting (typdelim). One-character string. */
  optional string typdelim = 6;

  /** Element type OID if this is an array type (typelem). */
  optional uint32 typelem = 7;
  
  /** Array type OID for this element type (typarray). */
  optional uint32 typarray = 8;

  /** Input function OID (typinput). */
  optional uint32 typinput = 9;

  /** Output function OID (typoutput). */
  optional uint32 typoutput = 10;

  /** Receive function OID (typreceive). */
  optional uint32 typreceive = 11;
  
  /** Send function OID (typsend). */
  optional uint32 typsend = 12;

  /** Type modifier input function OID (typmodin). */
  optional uint32 typmodin = 13;

  /** Type modifier output function OID (typmodout). */
  optional uint32 typmodout = 14;

  /** Alignment requirement (typalign). One-character string. */
  optional string typalign = 15;

  /** Collation OID (typcollation). */
  optional uint32 typcollation = 16;
  
  /** True if this is a preferred type within its category (typispreferred). */
  optional bool typispreferred = 17;
  
  /** Type category (typcategory). One-character PG code stored as a string. */
  optional string typcategory = 18;
}

/**
 * Type planning semantics (typcache accelerant).
 *
 * This is attached per type on SqlType.engine_specific.
 *
 * payload_type: "floe.type.planning_semantics+proto"
 */
message FloeTypePlanningSemantics {
  /** Type OID (pg_type.oid). */
  optional uint32 type_oid = 1;

  /** Equality operator OID (pg_operator.oid). */
  optional uint32 eq_op_oid = 2;

  /** B-tree comparison procedure OID (pg_proc.oid). Recommended. */
  optional uint32 btree_cmp_proc_oid = 3;

  /** B-tree less-than operator OID (pg_operator.oid). Optional. */
  optional uint32 btree_lt_op_oid = 4;

  /** B-tree greater-than operator OID (pg_operator.oid). Optional. */
  optional uint32 btree_gt_op_oid = 5;

  /** Hash support function OID (pg_proc.oid). */
  optional uint32 hash_proc_oid = 6;

  /** Default collation OID (pg_collation.oid). */
  optional uint32 default_collation_oid = 7;

  /** Preferred btree operator family OID (pg_opfamily.oid). */
  optional uint32 btree_opfamily_oid = 8;

  /** Preferred btree operator class OID (pg_opclass.oid). */
  optional uint32 btree_opclass_oid = 9;

  /** Preferred hash operator family OID (pg_opfamily.oid). */
  optional uint32 hash_opfamily_oid = 10;

  /** Preferred hash operator class OID (pg_opclass.oid). */
  optional uint32 hash_opclass_oid = 11;
}

/**
 * Engine-specific operator attributes (pg_operator).
 */
message FloeOperatorSpecific {
  /** Operator OID (pg_operator.oid). */
  optional uint32 oid = 1;

  /** Operator name (oprname). */
  optional string oprname = 2;

  /** Operator namespace OID (oprnamespace). */
  optional uint32 oprnamespace = 3;

  /** Operator kind (oprkind). */
  optional string oprkind = 4;

  /** True if operator can support merge joins (oprcanmerge). */
  optional bool oprcanmerge = 5;
  
  /** True if operator can support hash joins (oprcanhash). */
  optional bool oprcanhash = 6;

  /** Left operand type OID (oprleft). */
  optional uint32 oprleft = 7;

  /** Right operand type OID (oprright). */
  optional uint32 oprright = 8;

  /** Result type OID (oprresult). */
  optional uint32 oprresult = 9;

  /** Commutator operator OID (oprcom). */
  optional uint32 oprcom = 10;

  /** Negator operator OID (oprnegate). */
  optional uint32 oprnegate = 11;

  /** Operator implementation function OID (oprcode). */
  optional uint32 oprcode = 12;

  /** Selectivity estimation function OID (oprrest). */
  optional uint32 oprrest = 13;

  /** Join selectivity estimation function OID (oprjoin). */
  optional uint32 oprjoin = 14;
}

/**
 * Engine-specific aggregate attributes (pg_aggregate).
 */
message FloeAggregateSpecific {
  /** Aggregate function OID (aggfnoid). */
  optional uint32 aggfnoid = 1;

  /** Aggregate kind (aggkind). */
  optional string aggkind = 2;

  /** Number of direct arguments (aggnumdirectargs). */
  optional int32 aggnumdirectargs = 3;

  /** Transition function OID (aggtransfn). */
  optional uint32 aggtransfn = 4;

  /** Final function OID (aggfinalfn). */
  optional uint32 aggfinalfn = 5;

  /** Moving-aggregate transition function OID (aggmtransfn). */
  optional uint32 aggmtransfn = 6;

  /** Inverse transition function OID (aggminvtransfn). */
  optional uint32 aggminvtransfn = 7;

  /** Moving-aggregate final function OID (aggmfinalfn). */
  optional uint32 aggmfinalfn = 8;

  /** True if final function receives extra args (aggfinalextra). */
  optional bool aggfinalextra = 9;

  /** True if moving-aggregate final function receives extra args (aggmfinalextra). */
  optional bool aggmfinalextra = 10;

  /** Sort operator OID (aggsortop). */
  optional uint32 aggsortop = 11;

  /** Transition state type OID (aggtranstype). */
  optional uint32 aggtranstype = 12;

  /** Transition state space estimate (aggtransspace). */
  optional int32 aggtransspace = 13;

  /** Moving transition state type OID (aggmtranstype). */
  optional uint32 aggmtranstype = 14;

  /** Moving transition state space estimate (aggmtransspace). */
  optional int32 aggmtransspace = 15;

  /** Initial transition value (agginitval). */
  optional string agginitval = 16;

  /** Initial moving transition value (aggminitval). */
  optional string aggminitval = 17;
}

/**
 * Engine-specific collation attributes (pg_collation).
 */
message FloeCollationSpecific {
  /** Collation OID (pg_collation.oid). */
  optional uint32 oid = 1;

  /** Collation name (collname). */
  optional string collname = 2;

  /** Namespace OID (collnamespace). */
  optional uint32 collnamespace = 3;

  /** Encoding identifier (collencoding). */
  optional int32 collencoding = 4;

  /** LC_COLLATE setting (collcollate). */
  optional string collcollate = 5;

  /** LC_CTYPE setting (collctype). */
  optional string collctype = 6;
}

/**
 * Registry-level access method dictionary (pg_am).
 *
 * This is emitted once per (engine_kind, engine_version) and attached to
 * SystemObjectsRegistry.engine_specific.
 *
 * payload_type: "floe.access_methods+proto"
 */
message FloeAccessMethods {
  /** Access methods known to the engine. */
  repeated AccessMethod methods = 1;

  message AccessMethod {
    /** Access method OID (pg_am.oid). */
    optional uint32 oid = 1;

    /** Access method name (amname). Example: "btree", "hash". */
    optional string amname = 2;
  }
}

/**
 * Registry-level operator family dictionary (pg_opfamily).
 *
 * This is emitted once per (engine_kind, engine_version) and attached to
 * SystemObjectsRegistry.engine_specific.
 *
 * payload_type: "floe.operator_families+proto"
 */
message FloeOperatorFamilies {
  /** Operator families known to the engine. */
  repeated OperatorFamily families = 1;

  message OperatorFamily {
    /** Operator family OID (pg_opfamily.oid). */
    optional uint32 oid = 1;

    /** Access method OID (opfmethod -> pg_am.oid). */
    optional uint32 opfmethod = 2;

    /** Family name (opfname). Optional/debug. */
    optional string opfname = 3;

    /** Namespace OID (opfnamespace). Optional/debug. */
    optional uint32 opfnamespace = 4;
  }
}

/**
 * Registry-level operator class dictionary (pg_opclass).
 *
 * This is emitted once per (engine_kind, engine_version) and attached to
 * SystemObjectsRegistry.engine_specific.
 *
 * payload_type: "floe.operator_classes+proto"
 */
message FloeOperatorClasses {
  /** Operator classes known to the engine. */
  repeated OperatorClass classes = 1;

  message OperatorClass {
    /** Operator class OID (pg_opclass.oid). */
    optional uint32 oid = 1;

    /** Operator family OID (opcfamily -> pg_opfamily.oid). */
    optional uint32 opcfamily = 2;

    /** Input type OID (opcintype -> pg_type.oid). */
    optional uint32 opcintype = 3;

    /** Access method OID (opcmethod -> pg_am.oid). */
    optional uint32 opcmethod = 4;

    /** True if default opclass for opcintype */
    optional bool opcdefault = 5;

    /** Operator class name (opcname). Optional/debug. */
    optional string opcname = 6;

    /** Namespace OID (opcnamespace). Optional/debug. */
    optional uint32 opcnamespace = 7;
  }
}

/**
 * Registry-level operator access methods dictionary (pg_amop).
 *
 * This is emitted once per (engine_kind, engine_version) and attached to
 * SystemObjectsRegistry.engine_specific.
 *
 * payload_type: "floe.operator_access_methods+proto"
 */
message FloeOperatorAccessMethods {
  /** Strategy entries mapping index semantics to operators. */
  repeated OperatorAccessMethod entries = 1;

  message OperatorAccessMethod {
    /** Operator family OID (amopfamily -> pg_opfamily.oid). */
    optional uint32 amopfamily = 1;

    /** Strategy number (amopstrategy). */
    optional uint32 amopstrategy = 2;

    /** Left type OID (amoplefttype -> pg_type.oid). */
    optional uint32 amoplefttype = 3;

    /** Right type OID (amoprighttype -> pg_type.oid). */
    optional uint32 amoprighttype = 4;

    /** Operator OID (amopopr -> pg_operator.oid). */
    optional uint32 amopopr = 5;

    /**
     * Purpose flag (amoppurpose). Optional.
     *
     * Typically:
     *  - "s" for search semantics
     *  - "o" for ordering semantics
     */
    optional string amoppurpose = 6;

    /** Sort family OID (amopsortfamily -> pg_opfamily.oid). Optional. */
    optional uint32 amopsortfamily = 7;
    
    /** Access method OID (amopmethod -> pg_am.oid). */
    optional uint32 amopmethod = 8;
  }
}

/**
 * Registry-level procedure access methods dictionary (pg_amproc).
 *
 * This is emitted once per (engine_kind, engine_version) and attached to
 * SystemObjectsRegistry.engine_specific.
 *
 * payload_type: "floe.procedure_access_methods+proto"
 */
message FloeProcedureAccessMethods {
  /** Support procedure entries mapping AM procedures to functions. */
  repeated ProcedureAccessMethod entries = 1;

  message ProcedureAccessMethod {
    /** Operator family OID (amprocfamily -> pg_opfamily.oid). */
    optional uint32 amprocfamily = 1;

    /** Function number (amprocnum). */
    optional uint32 amprocnum = 2;

    /** Left type OID (amproclefttype -> pg_type.oid). */
    optional uint32 amproclefttype = 3;

    /** Right type OID (amprocrighttype -> pg_type.oid). */
    optional uint32 amprocrighttype = 4;

    /** Function OID (amproc -> pg_proc.oid). */
    optional uint32 amproc = 5;
  }
}

/**
 * NOTE: EngineSpecific extension field names were moved to engine_floe_extensions.proto.
 * That file uses a short proto package (`floe.ext`) to keep PBtxt bracket notation concise.
 * The message types remain defined in this file.
 */
