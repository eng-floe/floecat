# Copyright 2026 Yellowbrick Data, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

MC_NOT_FOUND=Resource not found.
MC_INVALID_ARGUMENT=Invalid argument.
MC_PRECONDITION_FAILED=Precondition failed.
MC_CONFLICT=Conflict detected.
MC_INTERNAL=Internal error: {cause} (root={root_class}, error={error_class}, message={root_message}).
MC_INTERNAL.internal.error=Internal error occurred.
MC_ABORT_RETRYABLE=Conflict detected, retry.
MC_UNAUTHENTICATED=Authentication required.
MC_PERMISSION_DENIED=You do not have permission to perform this operation.
MC_RATE_LIMITED=Too many requests. Try again later.
MC_UNAVAILABLE=Service temporarily unavailable.
MC_TIMEOUT=The operation timed out.
MC_CANCELLED=Request cancelled.
MC_SNAPSHOT_EXPIRED=Snapshot is no longer available.
MC_UNSPECIFIED=An error occurred.

MC_PERMISSION_DENIED.system.object.immutable=System objects cannot be modified.

MC_CONFLICT.already.exists={resource} already exists: {name}.

MC_NOT_FOUND.account=Account not found: {id}.
MC_NOT_FOUND.catalog=Catalog not found: {id}.
MC_NOT_FOUND.namespace=Namespace not found: {id}.
MC_NOT_FOUND.table=Table not found: {id}.
MC_NOT_FOUND.view=View not found: {id}.
MC_NOT_FOUND.snapshot=Snapshot not found: {id}.
MC_NOT_FOUND.connector=Connector not found: {id}.
MC_NOT_FOUND.job=Job not found: {id}.
MC_NOT_FOUND.table.stats=Table statistics for snapshot "{snapshot_id}" not found for table "{table_id}".
MC_NOT_FOUND.system.scan.scanner.not.found=System scanner "{scanner_id}" not found.

MC_CONFLICT.account.already.exists=Account "{display_name}" already exists.
MC_CONFLICT.account.not.empty=Account "{display_name}" contains catalogs.
MC_CONFLICT.catalog.already.exists=Catalog "{display_name}" already exists.
MC_CONFLICT.catalog.not.empty=Catalog "{display_name}" contains namespaces.
MC_CONFLICT.namespace.already.exists=Namespace "{path}" already exists in catalog "{catalog}".
MC_CONFLICT.namespace.not.empty=Namespace "{display_name}" contains tables and/or children.
MC_CONFLICT.table.already.exists=Table "{display_name}" already exists in namespace.
MC_CONFLICT.view.already.exists=View "{display_name}" already exists in namespace.
MC_CONFLICT.connector.already.exists=Connector "{display_name}" already exists.
MC_CONFLICT.idempotency.mismatch=Idempotency key mismatch for {op}: key={key}.
MC_CONFLICT.idempotency.already.succeeded.not.replayable=Idempotency succeeded; not replayable for {op}: key={key}.
MC_CONFLICT.snapshot.mismatch=Snapshot metadata mismatch detected.

MC_NOT_FOUND.namespace.by.path.missing=Namespace not found for catalog={catalog}, path={path}.
MC_NOT_FOUND.table.by.name.missing=Table not found for {catalog}.{path}.{name}.
MC_NOT_FOUND.view.by.name.missing=View not found for {catalog}.{path}.{name}.
MC_NOT_FOUND.connector.destination.catalog.not.found=The destination catalog is not found: {display_name}.
MC_NOT_FOUND.query.not.found=Query not found: {query_id}.
MC_NOT_FOUND.query.table.not.pinned=Table "{table_id}" is not pinned for query "{query_id}".
MC_NOT_FOUND.query.input.unresolved=Query input could not be resolved: {name}.
MC_NOT_FOUND.systemcatalog.not.found=Builtin catalog not found for engine version: {engine_version}.

MC_PRECONDITION_FAILED.version.mismatch=Version mismatch (expected {expected}, got {actual}).
MC_PRECONDITION_FAILED.catalog.children.changed=Catalog metadata changed while evaluating the request.
MC_PRECONDITION_FAILED.namespace.children.changed=Namespace metadata changed while evaluating the request.
MC_PRECONDITION_FAILED.query.not.active=The query is not in an active state.
MC_PRECONDITION_FAILED.etag.mismatch=ETag mismatch (expected {expected}, got {actual}).

MC_INTERNAL.query.expansion.parse.failed=Failed to parse the expansion.
MC_INTERNAL.catalog.bundle.snapshot.parse.failed=Failed to parse the bundle snapshot.
MC_INTERNAL.query.as.of.default.parse.failed=Failed to parse the 'as_of' timestamp.
MC_INTERNAL.query.snapshot.parse.failed=Failed to parse the snapshot.
MC_INTERNAL.scanbundle.stats.unavailable=Statistics data unavailable while building a bundle.
MC_INTERNAL.system.scan.missing.scanner=Unable to locate system scanner "{scanner_id}".

MC_INVALID_ARGUMENT.field=Invalid value for {field}.
MC_INVALID_ARGUMENT.kind=Invalid kind for {field}.
MC_INVALID_ARGUMENT.catalog.missing=Catalog is required.
MC_INVALID_ARGUMENT.table.name.missing=Table name is required.
MC_INVALID_ARGUMENT.path.segment.blank=Path segment cannot be blank.
MC_INVALID_ARGUMENT.selector.required=Selector is required.
MC_INVALID_ARGUMENT.page.token.invalid=Invalid page token: {page_token}.
MC_INVALID_ARGUMENT.query.inputs.required=Query inputs are required.
MC_INVALID_ARGUMENT.query.target.required=Query target is required.
MC_INVALID_ARGUMENT.query.table.id.required=Table id is required for this query request.
MC_INVALID_ARGUMENT.query.snapshots.missing=Snapshots are not available for this query.
MC_INVALID_ARGUMENT.snapshot.missing=Snapshot is required.
MC_INVALID_ARGUMENT.snapshot.special.missing=Snapshot SPECIAL is required.
MC_INVALID_ARGUMENT.update.mask.required=Update field mask is required.
MC_INVALID_ARGUMENT.update.mask.path.invalid=Update field mask is invalid: {path}.
MC_INVALID_ARGUMENT.catalog.id.cannot.clear=Catalog id cannot be cleared.
MC_INVALID_ARGUMENT.namespace.id.cannot.clear=Namespace id cannot be cleared.
MC_INVALID_ARGUMENT.namespace.catalog.mismatch=Namespace "{namespace_id}" belongs to catalog "{namespace_catalog_id}", but catalog_id was "{catalog_id}".
MC_INVALID_ARGUMENT.display.name.required=Display name is required.
MC_INVALID_ARGUMENT.display.name.cannot.clear=Display name cannot be cleared.
MC_INVALID_ARGUMENT.account.id.id.required=Account id is required.
MC_INVALID_ARGUMENT.account.id.kind.invalid=Account id kind must be RK_ACCOUNT (was {kind}).
MC_INVALID_ARGUMENT.schema.json.cannot.clear=Schema cannot be cleared.
MC_INVALID_ARGUMENT.uri.cannot.clear=URI cannot be cleared.
MC_INVALID_ARGUMENT.sql.cannot.clear=SQL cannot be cleared.
MC_INVALID_ARGUMENT.connector.destination.catalog.mismatch=Connector destination catalog id "{catalog_id}" does not match the catalog name "{catalog_display_name}".
MC_INVALID_ARGUMENT.connector.missing.source.namespace=Connector source namespace is required: {field}.
MC_INVALID_ARGUMENT.connector.missing.destination.catalog=Connector destination catalog is required: {field}.
MC_INVALID_ARGUMENT.engine.version.required=Engine version header is required: {header}.
MC_INVALID_ARGUMENT.builtin.engine.version.required=Engine version header is required: {header}.
MC_INVALID_ARGUMENT.builtin.engine.kind.required=Engine kind header is required: {header}.
MC_INVALID_ARGUMENT.update.mask.upstream.mix.forbidden=Cannot mix 'upstream' and 'upstream.*' in update.mask.
MC_INVALID_ARGUMENT.upstream.missing.for.replacement=Upstream replacement is required.
MC_INVALID_ARGUMENT.upstream.connector.id.required=Upstream connector id is required.
MC_INVALID_ARGUMENT.upstream.namespace.path.required=Upstream namespace path is required.
MC_INVALID_ARGUMENT.upstream.namespace.path.segment.blank=Upstream namespace path segment is blank.
MC_INVALID_ARGUMENT.upstream.table.display.name.required=Upstream table name is required.
MC_INVALID_ARGUMENT.upstream.column.id.algorithm.invalid=Upstream column id algorithm is invalid.
MC_INVALID_ARGUMENT.view.missing.catalog.id=View specification does not contain a catalog id.
MC_INVALID_ARGUMENT.view.missing.namespace.id=View specification does not contain a namespace id.
MC_INVALID_ARGUMENT.view.missing.spec=View does not contain a specification.
MC_INVALID_ARGUMENT.view.name.missing=View is missing a name.
MC_INVALID_ARGUMENT.column.stats.empty=Column statistics must not be empty.
MC_INVALID_ARGUMENT.stats.inconsistent.target=Stated statistics target does not match snapshot.
MC_INVALID_ARGUMENT.idempotency.inconsistent.key=Idempotent key partial matches record {key}, but differs.
MC_INVALID_ARGUMENT.spec.required=Snapshot spec is required.
MC_INVALID_ARGUMENT.spec.missing.ids=Snapshot spec is missing partition IDs.
MC_INVALID_ARGUMENT.catalog.bundle.candidate.missing=The catalog bundle candidate is missing.
MC_INVALID_ARGUMENT.catalog.bundle.schema.duplicate.column=The bundle schema contains a duplicate column: {column}.
MC_INVALID_ARGUMENT.catalog.bundle.schema.unknown.column=The bundle schema references an unknown column: {column}.
MC_INVALID_ARGUMENT.file.column.stats.empty=At least one column stats entry must be provided.
MC_INVALID_ARGUMENT.planner.stats.request.column.id.invalid=Column id in planner stats request is invalid.
MC_INVALID_ARGUMENT.planner.stats.request.columns.limit=Planner stats columns exceeds limit {max_columns}.
MC_INVALID_ARGUMENT.planner.stats.request.columns.missing=Planner stats request must declare columns.
MC_INVALID_ARGUMENT.planner.stats.request.table.id.missing=Planner stats request must include a table id.
MC_INVALID_ARGUMENT.planner.stats.request.tables.limit=Planner stats tables exceeds limit {max_tables}.
MC_INVALID_ARGUMENT.planner.stats.request.tables.missing=Planner stats request must include tables.
MC_INVALID_ARGUMENT.query.catalog.required=Query catalog is required.
MC_INVALID_ARGUMENT.query.input.ambiguous=Query input reference is ambiguous: {name}.
MC_INVALID_ARGUMENT.query.input.invalid=Query input is invalid for this request.
MC_INVALID_ARGUMENT.query.input.not.table=Query input must be a table.
MC_INVALID_ARGUMENT.query.input.view.cannot.use.snapshot.id=Views cannot be resolved with snapshot_id.
MC_INVALID_ARGUMENT.query.snapshot.required=Query snapshot is required.
MC_INVALID_ARGUMENT.snapshot.iceberg.required=Snapshot iceberg metadata is required.
MC_INVALID_ARGUMENT.snapshot.manifest.list.required=Snapshot manifest list is required.
MC_INVALID_ARGUMENT.snapshot.partition.spec.required=Snapshot partition spec is required.
MC_INVALID_ARGUMENT.snapshot.schema.id.required=Snapshot schema id is required.
MC_INVALID_ARGUMENT.snapshot.sequence.number.required=Snapshot sequence number is required.
MC_INVALID_ARGUMENT.snapshot.special.unsupported=Snapshot special is unsupported.
MC_INVALID_ARGUMENT.snapshot.upstream.created.at.required=Snapshot upstream created at timestamp is required.
MC_INVALID_ARGUMENT.system.output.format.unrecognized=System output format is unrecognized.
MC_INVALID_ARGUMENT.system.scan.not.system.table=This scan only works for system tables.
MC_INVALID_ARGUMENT.system.table.id.required=System table id is required.
MC_CONFLICT.snapshot.already.exists=Snapshot already exists for id "{snapshot_id}".
MC_INVALID_ARGUMENT.snapshot.schema.json.required=Snapshot schema JSON is required.
